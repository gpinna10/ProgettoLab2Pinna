Relazione Progetto 

Giovanni Giuseppe Pinna

Client1:

Client1 è un programma client scritto in C che prende in input un singolo file, che grazie alla funzione getline() viene suddiviso in righe che vengono inviate al server, l'apertura avviene grazie a fopen() con l'opzione 'r' per abilitare solo la lettura. Per la connessione creo una socket, ossia un'astrazione di comunicazione tra processi, utilizzando i protocolli IPv4 (AF_INET) e connessione TCP-IP, con la struct serv_addr inserisco anche la porta e l'indirizzo di connessione. Con il comando connect() connetto la socket all'indirizzo scritto su serv.addr e inizio la comunicazione tra Client e Server, inanzitutto informo il server che la connessione è di "Tipo A", con la funzione getline() ricevo la sequenza e la lunghezza di essa, quest'ultima viene codificata con htonl e inviata con writen(), funzione che esegue un ciclo fino a quando tutti i dati non sono stati inviati per evitare l'invio di dati incompleti o parziali. Per l'invio della sequenza ho utilizzato write(), una funzione utilizzata per scrivere dati da un buffer (line) ad un file (fd_socket). Infine in client invia al server una sequenza vuota per avvertirlo che il file è terminato, viene chiusa la connessione, il file preso in input e liberata la memoria allocata dal buffer line.

Client2: 

Molto simile al client1 a differenza che si possono ricevere un numero indefinito di file in input. In questo programma ogni file viene gestito da un thread che viene creato con xpthread_create(), funzione che permette la creazione di un thread, il nuovo thread inizia invocando task, una funzione con comportamente uguale a client1, gli argomenti della task sono formati da un array di struct a cui, l'i-esimo thread riceve il nome del file da gestire e nsq, il numero di sequenze inviate al server con un file, che viene sommato per mostrare il numero totale di sequenze inviate al server durante tutta la connessione. Infine dealloco l'array poichè inizialmente è stato allocato con malloc.

Server:

A differenza dei client, il server è un programma implementato in python. All'inizio il server, nel main, apre 'caposc' e 'capolet', due unnamed pipe, ossia dei file speciali che permettono la comunicazione di thread all'interno di un processo, è da specificare che le pipe sono unidirezionali, ossia è possibile eseguire o solo la scrittura o solo la lettura, nella funzione per la creazione della pipe os.mkfifo() oltre al nome abbiamo anche la costante che definisce i permessi della fifo, "0o666" è un codice ottale che permette a tutti di leggere e scrivere. Dopo che abbiamo aperto le pipe viene fatto partire archivio (con o senza valgrind a secondo di -v) tramite subprocess, funzione che permette di eseguire processi esterni al programma python, con gli argomenti -r e -w inseriti dal terminale, ossia il numero dei lettori e scrittori. Dopo l'esecuzione di archivio, apro le pipe (in sola scrittura) e inizializzo un file denominato "server.log" dove scriverò tutte le sequenze inviate ad archivio. Ora viene creato un threadpool, tecnica che permette la creazione di un gruppo (pool) di thread a cui assegnare dei task che essi eseguiranno concorrentemente. Per la comunicazione apro una socket con gli argomenti AF_INET e SOCK_STREAM già indicati in client1, assegno l'indirizzo e porta grazie a bind e con listen(), il server si mette in ascolto, ossia aspetta (attivamente) che i client si colleghi e scambino le sequenze. L'attesa attiva avviene grazie ad un while true, quando un client si collega il server grazie server.accept() accetta la richiesta del client e fa eseguire ad uno thread del pool gestisci_connessione() con la socket, l'indirizzo e le due pipe. Infine quando il processo viene terminato con pkill -INT -f, si invia il segnale al processo server.py che grazie a signal() lo ricevo ed esegue il signal_handler, una funzione che chiude le pipe, il server, invia un segnale di terminazione ad archivio (SIGTERM) ed esegue la exit(). La funzione gestione_connessione, come dice il nome, gestisce la connessione tra i client ed il server. Come prima cosa il server deve capire con quale tipo connessione sta lavorando, riceve dal client la stringa e tramite un if controlla di che tipo si tratta. Se la connessione è di tipo A, riceve tramite recv_all la lunghezza (4 sono i byte che deve ricevere, 4 byte è la dimensione degli interi), ora in len_byte ho una sequenza di byte, la lunghezza della stringa (len_s) sta nei quattro byte più significativi, perciò eseguo la unpack("!i", len_byte[:4])[0] per indicare di prendere i primi quattro byte e convertirli in un intero. Ora che ho la lunghezza eseguo una recv_all che riceve la sequenza con lunghezza pari ha len_s. Codifico ora len_s in una stringa di byte che verra scritta sulla pipe capolet previa scrittura della lunghezza della sequenza (in byte), aggiorno il contatore byte_inviati, scrivo in server.log i byte inviati e chiudo la connessione. Nel caso di connessione di tipo B il procedimento è pressochè uguale al Tipo A a differenza che quando la connessione termina con il ricevimento della sequenza vuota invia al client le sequenze ricevuto da quest'ultimo. Infine quando devo far partire dal terminale server.py aggiungo una descrizione che indica a cosa servono gli argomenti -r -w e -v, ed in caso di scritture errate indica come scrivere correttamente gli argomenti di ./server.py.

Archivio:

Archivio è un programma in c, qui vengono immagazzinati in una hash table tutti i messaggi inviati dai client al server. Questo programma utilizza thread lettori e scrittori, con due capi che ricevono le sequenze dalle pipe dal server e li inseriscono nei buffer appositi. Inanzitutto nel main creiamo un hash table con hcreate, inizializziamo tutti i thread, e le struct (reader e writer) contenenti tutti gli argomenti che verranno utilizzati all'interno dei task del thread. I task dei capi (t_capolet e t_caposc), come precedentemente scritto, aprono la pipe in sola lettura per ricevere le sequenze che il server ha ricevuto dai client grazie alla funzione read(). Le sequenze vengono tokenizzate con strtok(), ossia grazie a dei delimitatori la sequenza principale viene divisa in sottostringhe. I token vengono inseriti nell'apposito buffer (reader o writer), visto che si tratta di una memoria condivisa si deve creare una mutua esclusione, infatti utilizzo due semafori, sem_full con contatore pari a PC_buffer_len e sem_empty che parte da 0. Dopo aver fatto la wait su sem_full inserisco il token nel buffer, incremento l'indice ed eseguo la post che incrementa il contatore di sem_empty. Quando la pipe viene chiusa ricevo una sequenza nulla, in questo caso riempio il buffer con valori NULL e risveglio con post i thread lettori/scrittori. I task lettori/scrittori eseguono una wait su sem_empty in attesa che il buffer abbia token all'interno, quando vengono svegliati, estraggono il token dal buffer eseguono le operazioni sulla hash table, scrittori inserisce con aggiungi(), invece lettori esegue conta() e stampa ,su lettori.log, il token e le sue occorrenze. Trattandosi anche la hashtable di una memoria condivisa, creiamo una mutua ricorsione utilizzando le lock, queste lock utilizzano il paradigma lettori/scrittori, nel mio caso si usano le lock di rwunfair che sfrutta una gestione writer unfair, perchè i lettori se ci sono altri lettori attivi possono accedere alla hash table mentre gli scrittori possono accedere uno alla volta e devono attendere che i lettori in attesa abbiano terminato. Dopo aver eseguito le operazioni sulla hash table viene deallocato il token e risvegliato il capo con la post su sem_full. Per i segnali inviati dal server abbiamo un signal handler, una funzione apposita per la gestione dei segnali, questo handler prende come argomenti una struct contente i thread capolettore e caposcrittore. Per prima cosa inizializzo la maschera nel main con sigemptyset, e con sigaddset aggiungo i SIGINT, SINGTERM, SIGUSR1, per poi utilizzare pthread_sigmask, una funzione che prende i segnali che "blocca" i segnali inseriti nel set ed esegue il signal_handler. Nell'handler dopo aver ricreato la mask, creo un intero che riceve dalla sigwait il numero del segnale e in base a quello faccio le operazioni. Quando ricevo il SIGINT allora stampo il numero di elementi presenti in tabella, con la SIGUSR1 libero la tabella ma posso continuare l'esecuzione del programma ed invece con la SIGTERM libero la tabella hash ed eseguo tutte le operazioni di deallocazione della memoria e termino il programma.
